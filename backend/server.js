require('dotenv').config();
const express = require('express');
const oracledb = require('oracledb');
const cors = require('cors');
const morgan = require('morgan');
const dbConfig = require('./dbConfig');

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(morgan('dev'));
// Increase payload limit to handle multiple images (200mb for lossless PNGs)
app.use(express.json({ limit: '200mb' }));

// Helper to strip Base64 prefix (data:image/jpeg;base64,...)
const parseBase64Data = (dataString) => {
  const matches = dataString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);
  if (matches && matches.length === 3) {
    return Buffer.from(matches[2], 'base64');
  }
  // Fallback if no prefix sent
  return Buffer.from(dataString, 'base64');
};

// --- ROUTES ---

// Health Check
app.get('/api/health', async (req, res) => {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute('SELECT 1 FROM DUAL');
    res.json({ status: 'online', db: 'connected' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ status: 'offline', error: err.message });
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (e) {
        console.error(e);
      }
    }
  }
});


app.get('/api/v1/doctors', async (req, res) => {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT DR_ID, DR_NAME FROM DOCTOR_INFO ORDER BY DR_NAME ASC`,
      [],
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    // Transform to simple array
    const doctors = result.rows.map((row) => ({
      id: row.DR_ID,
      name: row.DR_NAME,
    }));
    res.json(doctors);
  } catch (err) {
    console.error('Error fetching doctors:', err);
    res.status(500).json({ error: 'Failed to fetch doctors' });
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection:', err);
      }
    }
  }
});

// -----------------------------------------------------------------------------
// POST /api/v1/documents/sync
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// POST /api/v1/documents/sync
// -----------------------------------------------------------------------------
app.post('/api/v1/documents/sync', async (req, res) => {
  const { transactionId, metadata, attachments } = req.body;

  if (!transactionId || !metadata || !attachments) {
    return res.status(400).json({ message: 'Missing required fields' });
  }

  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);

    // 1. Check Idempotency based on UUID (frontend_uuid)
    const checkSql = `SELECT PATIENT_ID FROM PATIENT_INFO WHERE FRONTEND_UUID = :uuid`;
    const checkResult = await connection.execute(checkSql, { uuid: transactionId });

    if (checkResult.rows.length > 0) {
      // Already synced
      return res.json({
        message: 'Document already synced',
        documentId: checkResult.rows[0][0], // PATIENT_ID
      });
    }

    // 2. Insert Master Record (PATIENT_INFO)
    // Using numeric ID (generated by identity), AGE as number, and new columns
    const sqlMaster = `
      INSERT INTO PATIENT_INFO (
        FRONTEND_UUID, PATIENT_NAME, GENDER, DOB, AGE, CONTACT_NO, ADDRESS, DOCTOR_NAME, CREATED_AT
        -- Additional columns can be added here as frontend supports them
        -- E.g. PS, PO, DIST, etc. Currently defaulting to NULL via implicit omission
      )
      VALUES (
        :uuid, :name, :gender, TO_DATE(:dob, 'YYYY-MM-DD'), :age, :contact, :address, :doctorName, 
        TIMESTAMP '1970-01-01 00:00:00' + NUMTODSINTERVAL(:createdAt / 1000, 'SECOND')
      )
      RETURNING PATIENT_ID INTO :id
    `;

    const resultMaster = await connection.execute(sqlMaster, {
      uuid: transactionId,
      name: metadata.fullName,
      gender: metadata.gender || null,
      dob: metadata.dateOfBirth,
      age: parseInt(metadata.age) || null, // Ensure Number
      contact: metadata.phoneNumber,
      address: metadata.address || null,
      doctorName: metadata.doctorName || null,
      createdAt: metadata.capturedAt,
      id: { type: oracledb.NUMBER, dir: oracledb.BIND_OUT }, // Expect NUMBER ID
    });


    // FILE_ID generated by Trigger/Sequence
    const sqlImage = `
      INSERT INTO PATIENT_DOC_INFO (PATIENT_ID, SEQUENCE_NO, PHOTO_MIME_TYPE, patient_doc)
      VALUES (:mid, :seq, :mime, :data)
    `;

    // Process attachments sequentially
    for (const att of attachments) {
      // att.data is base64 string.
      const base64Data = att.data.replace(/^data:image\/\w+;base64,/, '');
      const buffer = Buffer.from(base64Data, 'base64');

      await connection.execute(sqlImage, {
        mid: masterId,
        seq: att.sequence,
        mime: att.mimeType,
        data: buffer,
      });
    }

    await connection.commit();

    res.json({
      message: 'Sync successful',
      documentId: masterId,
    });
  } catch (err) {
    console.error('Sync Error:', err);
    res.status(500).json({ message: 'Internal Server Error', error: err.message });
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection:', err);
      }
    }
  }
});

// -----------------------------------------------------------------------------
// GET /api/v1/patients/search
// -----------------------------------------------------------------------------
app.get('/api/v1/patients/search', async (req, res) => {
  const { q } = req.query;
  if (!q) {
    return res.status(400).json({ message: 'Query parameter q is required' });
  }

  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);

    // Search by Name (Partial), Phone (Partial), or ID (Exact)
    // Using simple LIKE for now.
    // If q is numeric, we can check ID too.
    const isNumeric = /^\d+$/.test(q);

    let sql = `
      SELECT PATIENT_ID, PATIENT_NAME, CONTACT_NO, AGE, GENDER, DOCTOR_NAME, TO_CHAR(DOB, 'YYYY-MM-DD') as DOB_STR
      FROM PATIENT_INFO
      WHERE LOWER(PATIENT_NAME) LIKE LOWER(:term)
         OR CONTACT_NO LIKE :term
    `;

    const binds = { term: `%${q}%` };

    if (isNumeric) {
      sql += ` OR PATIENT_ID = :exactId`;
      binds.exactId = parseInt(q);
    }

    // Limit results for safety
    sql += ` FETCH FIRST 50 ROWS ONLY`;

    const result = await connection.execute(sql, binds, { outFormat: oracledb.OUT_FORMAT_OBJECT });

    const patients = result.rows.map(row => ({
      id: row.PATIENT_ID,
      name: row.PATIENT_NAME,
      phone: row.CONTACT_NO,
      age: row.AGE,
      gender: row.GENDER,
      doctorName: row.DOCTOR_NAME,
      dob: row.DOB_STR
    }));

    res.json(patients);
  } catch (err) {
    console.error('Search Error:', err);
    res.status(500).json({ message: 'Search failed', error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (e) { console.error(e); }
    }
  }
});

// -----------------------------------------------------------------------------
// GET /api/v1/patients/:id/images
// -----------------------------------------------------------------------------
app.get('/api/v1/patients/:id/images', async (req, res) => {
  const { id } = req.params;
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    // Fetch BLOBs. Note: Fetching BLOBs as base64 needs DB fetchAsString or manual buffer handling.
    // oracledb.fetchAsString = [ oracledb.CLOB ]; // BLOB needs special handling usually, but Buffer is default in 6.0+

    const sql = `
            SELECT FILE_ID, SEQUENCE_NO, PHOTO_MIME_TYPE, PATIENT_DOC
            FROM PATIENT_DOC_INFO
            WHERE PATIENT_ID = :pid
            ORDER BY SEQUENCE_NO ASC
        `;

    // Ensure PATIENT_DOC (column index 3) is fetched as Buffer
    const result = await connection.execute(sql, { pid: id }, {
      fetchInfo: {
        PATIENT_DOC: { type: oracledb.BUFFER }
      }
    });



    // Process BLOBs
    const images = [];
    for (const row of result.rows) {
      // row[0]=FILE_ID, row[1]=SEQ, row[2]=MIME, row[3]=BLOB
      const fileId = row[0];
      const seq = row[1];
      const mime = row[2];
      const lob = row[3];

      if (lob) {
        let data = '';
        if (Buffer.isBuffer(lob)) {
          data = lob.toString('base64');
        } else if (lob && typeof lob.getData === 'function') {
          // It's a Lob object (thick mode or certain thin configurations)
          // We need to read it.
          // Warning: reading LOBs in loop needs care with async.
          // For now, assume Buffer is returned by oracledb (default for BLOB in thin mode)
          // If we really get a Lob object, we might need to stream it.
          // Let's assume Buffer first as per default 'fetchInfo' behavior or thin mode.
        } else {
          // Try common conversion
          data = Buffer.from(lob).toString('base64');
        }

        // Debug
        // console.log(`File ${fileId} data length: ${data.length}`);

        images.push({
          fileId, // Use FILE_ID as ID
          sequence: seq,
          mimeType: mime,
          data: `data:${mime};base64,${data}` // Frontend expects Full Data URL
        });
      }
    }
    res.json(images);

  } catch (err) {
    console.error('Get Images Error:', err);
    res.status(500).json({ message: 'Failed to get images', error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (e) { console.error(e); }
    }
  }
});

// -----------------------------------------------------------------------------
// DELETE /api/v1/images/:fileId
// -----------------------------------------------------------------------------
app.delete('/api/v1/images/:fileId', async (req, res) => {
  const { fileId } = req.params;
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute(
      `DELETE FROM PATIENT_DOC_INFO WHERE FILE_ID = :fid`,
      { fid: fileId },
      { autoCommit: true }
    );
    res.json({ message: 'Image deleted' });
  } catch (err) {
    console.error("Delete Error", err);
    res.status(500).json({ message: 'Delete failed' });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (e) { console.error(e); }
    }
  }
});

// -----------------------------------------------------------------------------
// POST /api/v1/patients/:id/images
// -----------------------------------------------------------------------------
app.post('/api/v1/patients/:id/images', async (req, res) => {
  const { id } = req.params;
  const { images } = req.body; // Expects array of { data: "base64...", mimeType: "..." }

  if (!images || !Array.isArray(images) || images.length === 0) {
    return res.status(400).json({ message: 'No images provided' });
  }

  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);

    // Get current max sequence
    const seqRes = await connection.execute(
      `SELECT MAX(SEQUENCE_NO) FROM PATIENT_DOC_INFO WHERE PATIENT_ID = :pid`,
      { pid: id }
    );
    let maxSeq = seqRes.rows[0][0] || 0;

    const sqlImage = `
          INSERT INTO PATIENT_DOC_INFO (PATIENT_ID, SEQUENCE_NO, PHOTO_MIME_TYPE, PATIENT_DOC)
          VALUES (:pid, :seq, :mime, :data)
        `;

    for (const img of images) {
      maxSeq++;
      const base64Data = img.data.replace(/^data:image\/\w+;base64,/, '');
      const buffer = Buffer.from(base64Data, 'base64');

      await connection.execute(sqlImage, {
        pid: id,
        seq: maxSeq,
        mime: img.mimeType || 'image/png',
        data: buffer
      });
    }

    await connection.commit();
    res.json({ message: 'Images added successfully', count: images.length });

  } catch (err) {
    console.error('Add Images Error:', err);
    res.status(500).json({ message: 'Failed to add images', error: err.message });
  } finally {
    if (connection) {
      try { await connection.close(); } catch (e) { console.error(e); }
    }
  }
});

app.listen(PORT, () => {
  console.log(`Backend server running on port ${PORT}`);
  console.log(`Connecting to Oracle at ${dbConfig.connectString}`);
});
