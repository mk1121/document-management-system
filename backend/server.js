require('dotenv').config();
const express = require('express');
const oracledb = require('oracledb');
const cors = require('cors');
const morgan = require('morgan');
const dbConfig = require('./dbConfig');

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(morgan('dev'));
// Increase payload limit to handle multiple images (200mb for lossless PNGs)
app.use(express.json({ limit: '200mb' }));

// Helper to strip Base64 prefix (data:image/jpeg;base64,...)
const parseBase64Data = (dataString) => {
  const matches = dataString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);
  if (matches && matches.length === 3) {
    return Buffer.from(matches[2], 'base64');
  }
  // Fallback if no prefix sent
  return Buffer.from(dataString, 'base64');
};

// --- ROUTES ---

// Health Check
app.get('/api/health', async (req, res) => {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    await connection.execute('SELECT 1 FROM DUAL');
    res.json({ status: 'online', db: 'connected' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ status: 'offline', error: err.message });
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (e) {
        console.error(e);
      }
    }
  }
});


app.get('/api/v1/doctors', async (req, res) => {
  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);
    const result = await connection.execute(
      `SELECT DR_ID, DR_NAME FROM DOCTOR_INFO ORDER BY DR_NAME ASC`,
      [],
      { outFormat: oracledb.OUT_FORMAT_OBJECT }
    );
    // Transform to simple array
    const doctors = result.rows.map((row) => ({
      id: row.DR_ID,
      name: row.DR_NAME,
    }));
    res.json(doctors);
  } catch (err) {
    console.error('Error fetching doctors:', err);
    res.status(500).json({ error: 'Failed to fetch doctors' });
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection:', err);
      }
    }
  }
});

// -----------------------------------------------------------------------------
// POST /api/v1/documents/sync
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// POST /api/v1/documents/sync
// -----------------------------------------------------------------------------
app.post('/api/v1/documents/sync', async (req, res) => {
  const { transactionId, metadata, attachments } = req.body;

  if (!transactionId || !metadata || !attachments) {
    return res.status(400).json({ message: 'Missing required fields' });
  }

  let connection;
  try {
    connection = await oracledb.getConnection(dbConfig);

    // 1. Check Idempotency based on UUID (frontend_uuid)
    const checkSql = `SELECT PATIENT_ID FROM PATIENT_INFO WHERE FRONTEND_UUID = :uuid`;
    const checkResult = await connection.execute(checkSql, { uuid: transactionId });

    if (checkResult.rows.length > 0) {
      // Already synced
      return res.json({
        message: 'Document already synced',
        documentId: checkResult.rows[0][0], // PATIENT_ID
      });
    }

    // 2. Insert Master Record (PATIENT_INFO)
    // ID is generated by Trigger (VARCHAR2) based on Branch/Year
    const sqlMaster = `
      INSERT INTO PATIENT_INFO (
        FRONTEND_UUID, PATIENT_NAME, GENDER, DOB, AGE, CONTACT_NO, ADDRESS, DOCTOR_NAME, CREATED_AT,
        BRANCH_NAME, PATIENT_TYPE, APP_DATE, PO, PS, DIST, EMG_CONTACT_PERSON, EMG_CONTACT_NO, REF_BY
      )
      VALUES (
        :uuid, :name, :gender, TO_DATE(:dob, 'YYYY-MM-DD'), :age, :contact, :address, :doctorName, 
        TIMESTAMP '1970-01-01 00:00:00' + NUMTODSINTERVAL(:createdAt / 1000, 'SECOND'),
        :branchName, :patientType, TO_DATE(:appDate, 'YYYY-MM-DD'), :po, :ps, :dist, :emgPerson, :emgNo, :refBy
      )
      RETURNING PATIENT_ID INTO :id
    `;

    const resultMaster = await connection.execute(sqlMaster, {
      uuid: transactionId,
      name: metadata.fullName,
      gender: metadata.gender || null,
      dob: metadata.dateOfBirth,
      age: parseInt(metadata.age) || null,
      contact: metadata.phoneNumber,
      address: metadata.address || null,
      doctorName: metadata.doctorName || null,
      createdAt: metadata.capturedAt,
      // New Fields
      branchName: metadata.branchName || null, // FD1 / FD2
      patientType: metadata.patientType || null,
      appDate: metadata.appDate || null,
      po: metadata.po || null,
      ps: metadata.ps || null,
      dist: metadata.dist || null,
      emgPerson: metadata.emgContactPerson || null,
      emgNo: metadata.emgContactNo || null,
      refBy: metadata.refBy || null,

      id: { type: oracledb.STRING, dir: oracledb.BIND_OUT }, // Expect STRING ID from Trigger
    });

    const masterId = resultMaster.outBinds.id[0];
    console.log(`Inserted Patient ID: ${masterId}`);

    // 3. Insert Images (PATIENT_DOC_INFO)
    // FILE_ID generated by Trigger/Sequence
    const sqlImage = `
      INSERT INTO PATIENT_DOC_INFO (PATIENT_ID, SEQUENCE_NO, PHOTO_MIME_TYPE, patient_doc, NEXT_APP)
      VALUES (:mid, :seq, :mime, :data, TO_DATE(:nextApp, 'YYYY-MM-DD'))
    `;

    // Process attachments sequentially
    for (const att of attachments) {
      // att.data is base64 string.
      const base64Data = att.data.replace(/^data:image\/\w+;base64,/, '');
      const buffer = Buffer.from(base64Data, 'base64');

      await connection.execute(sqlImage, {
        mid: masterId,
        seq: att.sequence,
        mime: att.mimeType,
        data: buffer,
        nextApp: metadata.nextApp || null, // [NEW] Use nextApp from metadata
      });
    }

    await connection.commit();

    res.json({
      message: 'Sync successful',
      documentId: masterId,
    });
  } catch (err) {
    console.error('Sync Error:', err);
    res.status(500).json({ message: 'Internal Server Error', error: err.message });
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing connection:', err);
      }
    }
  }
});

app.listen(PORT, () => {
  console.log(`Backend server running on port ${PORT}`);
  console.log(`Connecting to Oracle at ${dbConfig.connectString}`);
});
